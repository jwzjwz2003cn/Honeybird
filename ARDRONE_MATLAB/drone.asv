classdef drone < handle

    properties
        ARcontrol  %a control instance
        ARnav      %navdata instance
        ARc = udp('192.168.1.1', 5556, 'LocalPort', 5556); %control port
        ARn = udp('192.168.1.1', 5554, 'LocalPort', 5554); %navdata port
        state
        battery
        pitch
        roll        
        yaw
        altitude  % millimeters
        vx
        vy
        vz
		kinect
        
    end
    
    methods
        
        function obj = drone()
            
            obj.battery = 0;
            obj.ARcontrol = control(obj.ARc);
            obj.ARnav = navdata(obj.ARn, obj.ARcontrol);
            obj.state = 0 ;          
            obj.pitch = 0;
            obj.roll = 0;
            obj.yaw = 0;
            obj.altitude = 0;
            obj.vx = 0;
            obj.vy = 0;
            obj.vz = 0;
            
		%	obj.kinect = Kinect_RadarBBOX;
            
        end
		
		function x_moveTo(obj, x_ref)
			Kp = 0.25;
			Ki = 0;
			Kd = 0.25;
			%roll_setting;
			%pitch_setting;
			x_pos = 0; % x position of the drone
			roll_setting=0;
			roll_max = 0.8; % maximum rolling 
			
			err_x=0;
			err_x1=0;


			while(err_x > 10 || err_x < -10)

				[drone_pos,ball_pos] = obj.kinect.TrackFrame();
				
                while(isempty(drone_pos) == 1)
                    disp('the drone_pos is empty');
                end
                
				% Cx(s)
                x_pos = drone_pos(1);
				err_x = -(x_ref - x_pos);
				roll_setting = Kp*err_x + Ki*(err_x+err_x1) + Kd*(err_x-err_x1)
				%roll_setting = Kp*err_x;
				roll_setting = roll_setting/1500;

				% Save the err[k-1]
				err_x1 = err_x;
				
				% Saturator
				if (roll_setting > roll_max)
					roll_setting = roll_max;
                elseif (roll_setting < -roll_max)
					roll_setting = -roll_max;
                end
                
				% roll_setting is calculated based on x_ref and x_pos
				% x_pos is the camera measurement which could be nan
                if(isnan(roll_setting) == 1)
                   roll_setting = 0;
                   disp('roll setting is nan');
                end
				
				% out of range
				if(x_pos > 1200 || x_pos < -1200)
					roll_setting = 0;
				end
				
				% Call the control function
				obj.x_control(roll_setting)

			end
			
			for i = 1:10
				[drone_pos,ball_pos] = obj.kinect.TrackFrame();
                
                 while(isempty(drone_pos) == 1)
                    disp('the drone_pos is empty');
                 end
                
                 
				x_pos = drone_pos(1);
				err_x = -(x_ref - x_pos);
				
				roll_setting = Kp*err_x + Ki*(err_x+err_x1) + Kd*(err_x-err_x1)
				err_x1 = err_x;
                
				roll_setting = roll_setting/1500;
				
				
				% Saturator
				if (roll_setting > roll_max)
					roll_setting = roll_max;
                elseif (roll_setting < -roll_max)
					roll_setting = -roll_max;
				end
				
				% out of range
				if(x_pos > 1200 || x_pos < -1200)
					roll_setting = 0;
                end
                
                if(isnan(roll_setting) == 1)
                   roll_setting = 0;
                   disp('roll setting is nan');
                end
				
				obj.x_control(roll_setting)
				pause(0.05);
			end
		end
		
		function y_moveTo(obj, y_ref)
			Kp = 0.25;
			Ki = 0;
			Kd = 0.25;
			%pitch_setting;
			%pitch_setting;
			y_pos = 0;
			pitch_setting=0;
			pitch_max = 0.8;
			
			err_y=0;
			err_y1=0;


			while(err_y > 10 || err_y < -10)

				[drone_pos,ball_pos] = obj.kinect.TrackFrame();
				
                while(isempty(drone_pos) == 1)
                    disp('the drone_pos is empty');
                end
                
                y_pos = drone_pos(3);
				err_y = (y_ref - y_pos);
				pitch_setting = Kp*err_y + Ki*(err_y+err_y1) + Kd*(err_y-err_y1)
				%pitch_setting = Kp*err_y;
				pitch_setting = pitch_setting/1500;

				% Save the err[k-1]
				err_y1 = err_y;
				
				% Saturator
				if (pitch_setting > pitch_max)
					pitch_setting = pitch_max;
                elseif (pitch_setting < -pitch_max)
					pitch_setting = -pitch_max;
                end
                
                if(isnan(pitch_setting) == 1)
                   pitch_setting = 0;
                   disp('roll setting is nan');
                end
				
				% out of range
				if(y_pos > 3000 || y_pos < 300)
					pitch_setting = 0;
				end
				
				% Call the control function
				obj.y_control(pitch_setting)
				pause(0.05);
			end
			
			for i = 1:10
				[drone_pos,ball_pos] = obj.kinect.TrackFrame();
                
                 while(isempty(drone_pos) == 1)
                    disp('the drone_pos is empty');
                 end
                
                 
				y_pos = drone_pos(3)
				err_y = (y_ref - y_pos);
				
				pitch_setting = Kp*err_y + Ki*(err_y+err_y1) + Kd*(err_y-err_y1)
				err_y1 = err_y;
                
				pitch_setting = pitch_setting/1500;
				
				
				% Saturator
				if (pitch_setting > pitch_max)
					pitch_setting = pitch_max;
                elseif (pitch_setting < -pitch_max)
					pitch_setting = -pitch_max;
				end
				
				% out of range
				if(y_pos > 3000 || y_pos < 300)
					pitch_setting = 0;
                end
                
                if(isnan(pitch_setting) == 1)
                   pitch_setting = 0;
                   disp('roll setting is nan');
                end
				
				obj.y_control(pitch_setting)
				pause(0.05);
			end
		end
		
		% z control
		function z_moveTo(obj, z_ref)
			Kp = 0.8;
			Ki = 0.5;
			Kd = 0.25;

			z_setting=0;
			err_z=0;
			err_z1=0;

			while(err_z > 10 || err_z < -10)
				%err_x = x_ref - obj.x
				%err_y = y_ref - obj.y
				obj.get_altitude;
				err_z = z_ref - obj.altitude;
				
				z_setting = Kp*err_z + Ki*(err_z+err_z1) + Kd*(err_z-err_z1)
				
				err_z1 = err_z;
				z_setting = z_setting / 1500;
				obj.z_control(z_setting)
				pause(0.05);
			end
			
			for i = 1:3
				obj.get_altitude;
				err_z = z_ref - obj.altitude;
				

				z_setting = Kp*err_z + Ki*(err_z+err_z1) + Kd*(err_z-err_z1)
				
				err_z1 = err_z;
				z_setting = z_setting / 1500;
				obj.z_control(z_setting)
				pause(0.05);
			end
		end
				
			
				
		function z_control(obj, gaz) %duplicated
            obj.reset_wdg();
            gaz_dec = (obj.float2dec(gaz));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,0,gaz_dec,0);
        end	
		
		function y_control(obj, pitch) %duplicated
            obj.reset_wdg();
            pitch_dec = (obj.float2dec(pitch));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,pitch_dec,0,0); 
        end
		
        function x_control(obj, roll) %duplicated
            obj.reset_wdg();
            roll_dec = (obj.float2dec(roll));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,roll_dec,0,0,0);             
        end
        
        function dec_num = float2dec(obj, float_num) %convert readable float to API supported signed dec
            single_float = single(float_num);
            signed_hex = num2hex(single_float);
            dec_num = typecast(uint32(hex2dec(signed_hex)),'int32');                        
        end
        
        function terminate(obj)
            obj.ARcontrol.terminate();
            obj.ARnav.terminate();
        end
        
        function takeoff(obj)
            obj.reset_wdg(); %reset watchdog to resume connection
            ref_arg = 290718208; 
            obj.ftrim();
            obj.ARcontrol.at_ref(ref_arg);
            
        end
        
        function land(obj)
            obj.reset_wdg();
            ref_arg = 290717696;
            obj.ARcontrol.at_ref(ref_arg);          
        end
        
                
        function reset(obj)    %reset ARDrone when 
            obj.reset_wdg();
            ref_arg = 290717952;
            obj.ARcontrol.at_ref(ref_arg); 
        end
        
        function move_forward(obj, speed)
            obj.reset_wdg();
            speed_dec = -(obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,speed_dec,0,0);       
        end
        
        function move_backward(obj, speed)
            obj.reset_wdg();
            speed_dec = (obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,speed_dec,0,0); 
        end
        
        function roll_left(obj, speed)
            obj.reset_wdg();
            speed_dec = -(obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,speed_dec,0,0,0);             
        end
        
        function roll_right(obj, speed)
            obj.reset_wdg();
            speed_dec = (obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,speed_dec,0,0,0);   
        end
            
        function go_up(obj, speed)
            obj.reset_wdg();
            speed_dec = (obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,0,speed_dec,0);
        end
        
        function go_down(obj, speed)
            obj.reset_wdg();
            speed_dec = -(obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,0,speed_dec,0);
        end

        
        function rotate_left(obj, speed)
            obj.reset_wdg();
            speed_dec = -(obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,0,0,speed_dec);
        end
        
        function rotate_right(obj, speed)
            obj.reset_wdg();
            speed_dec = (obj.float2dec(speed));
            prog_cmd = 1;
            obj.ARcontrol.at_pcmd(prog_cmd,0,0,0,speed_dec);
        end

        
        function ftrim(obj)
            obj.reset_wdg();
            obj.ARcontrol.at_ftrim();
        end

        function reset_ports(obj) %currently, navdata would only be acquired after a port reset
            tic;
            obj.ARcontrol.reset_port;
            obj.ARnav.reset_port;
            toc;
           % disp('reseting ports');
        end
        
        function reset_wdg(obj)
            obj.ARcontrol.at_comwdg();
        end
        
        function get_battery(obj)
            obj.reset_ports;
            obj.battery = obj.ARnav.decode_battery;
        end
        
        function get_pitch(obj)
            obj.reset_ports;
            obj.pitch = obj.ARnav.decode_pitch;
        end
        
        function get_roll(obj)
            obj.reset_ports;
            obj.roll = obj.ARnav.decode_roll;
        end
        
        function get_yaw(obj)
            obj.reset_ports;
            obj.yaw = obj.ARnav.decode_yaw;
        end
        
        function get_altitude(obj, hObject, evt)
            obj.reset_ports;
            alt = obj.ARnav.decode_altitude;
            obj.altitude = alt;
        end
        
        function get_vx(obj)    %unused
            obj.reset_ports;
            obj.vx = obj.ARnav.decode_vx;
        end
        
        function get_vy(obj)     %unused
            obj.reset_ports;
            obj.vy = obj.ARnav.decode_vy;
        end
        
        function get_vz(obj)      %unused
            obj.reset_ports;
            obj.vz = obj.ARnav.decode_vz; 
        end

    end
    
end

